<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>기하 문제 관리 시스템</title>

    <!-- MathJax 설정 -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true,
                tags: 'ams',
                macros: {
                    // 자주 사용하는 매크로 정의
                    numbering: '',  // \numbering은 무시
                    mybreak: '{, }',  // \mybreak 처리
                }
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            startup: {
                pageReady: () => {
                    return MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax initial typesetting complete');
                    });
                }
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* 왼쪽 사이드바 - 문제 목록 */
        .sidebar {
            width: 350px;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            background: #2196F3;
            color: white;
        }

        .sidebar-header h1 {
            font-size: 20px;
            margin-bottom: 10px;
        }

        .stats {
            font-size: 13px;
            opacity: 0.9;
        }

        .search-box {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        .search-box input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .problem-list {
            flex: 1;
            overflow-y: auto;
        }

        /* Folder structure */
        .folder-item {
            border-bottom: 1px solid #f0f0f0;
        }

        .category-folder {
            background: #fafafa;
        }

        .year-folder {
            background: #ffffff;
        }

        .folder-header {
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
            user-select: none;
        }

        .folder-header:hover {
            background: #f0f0f0;
        }

        .folder-icon {
            font-size: 10px;
            color: #666;
            width: 12px;
            display: inline-block;
            transition: transform 0.2s;
        }

        .folder-icon.expanded {
            transform: rotate(0deg);
        }

        .folder-label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
            flex: 1;
        }

        .folder-count {
            font-size: 12px;
            color: #999;
            font-weight: normal;
        }

        .folder-content {
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 2000px;
            }
        }

        /* Search mode headers */
        .search-category-header {
            padding: 10px 15px;
            background: #e3f2fd;
            font-weight: 600;
            font-size: 13px;
            color: #1976D2;
            border-bottom: 1px solid #bbdefb;
        }

        .search-year-header {
            padding: 8px 15px;
            padding-left: 35px;
            background: #f5f5f5;
            font-weight: 500;
            font-size: 12px;
            color: #666;
            border-bottom: 1px solid #e0e0e0;
        }

        .problem-item {
            padding: 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .problem-item:hover {
            background: #f8f8f8;
        }

        .problem-item.active {
            background: #e3f2fd;
            border-left: 3px solid #2196F3;
        }

        .problem-id {
            font-weight: bold;
            color: #2196F3;
            margin-bottom: 5px;
        }

        .problem-preview {
            font-size: 13px;
            color: #666;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .problem-badges {
            margin-top: 5px;
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            font-size: 11px;
            border-radius: 3px;
            margin-right: 5px;
        }

        .badge-tikz {
            background: #fff3e0;
            color: #e65100;
        }

        .badge-solution {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .badge-source {
            background: #e0f2f1;
            color: #00695c;
        }

        /* 오른쪽 메인 영역 */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .main-header {
            padding: 20px;
            border-bottom: 2px solid #f0f0f0;
            background: white;
        }

        .main-header h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            gap: 10px;
        }

        .tab {
            padding: 8px 16px;
            border: none;
            background: #f5f5f5;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.2s;
        }

        .tab.active {
            background: #2196F3;
            color: white;
        }

        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* 문제 보기 탭 */
        .problem-content {
            line-height: 2.0;
            font-size: 17px;
        }

        .problem-content p {
            margin-bottom: 15px;
        }

        .problem-box {
            padding: 15px;
            background: #f9f9f9;
            border-left: 3px solid #2196F3;
            margin: 10px 0;
            border-radius: 4px;
        }

        .figure {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
        }

        /* MathJax 수식 스타일 */
        mjx-container {
            overflow-x: auto;
            overflow-y: hidden;
        }

        /* 메타데이터 표시 */
        .metadata-view {
            line-height: 1.8;
        }

        .metadata-item {
            margin-bottom: 15px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 4px;
        }

        .metadata-item strong {
            display: block;
            color: #555;
            margin-bottom: 5px;
        }

        /* 그림 폴드아웃 버튼 */
        .figure-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin: 25px 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px dashed #dee2e6;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .figure-toggle:hover {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-color: #2196F3;
            transform: scale(1.01);
        }

        .figure-toggle-icon {
            width: 50px;
            height: 50px;
            background: #2196F3;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
            transition: all 0.3s ease;
        }

        .figure-toggle:hover .figure-toggle-icon {
            background: #1976D2;
            box-shadow: 0 6px 16px rgba(33, 150, 243, 0.4);
            transform: scale(1.1);
        }

        .figure-toggle-icon svg {
            width: 24px;
            height: 24px;
            fill: white;
            margin-left: 3px;
        }

        .figure-toggle.expanded .figure-toggle-icon svg {
            transform: rotate(90deg);
            margin-left: 0;
        }

        .figure-toggle-text {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
        }

        .figure-toggle:hover .figure-toggle-text {
            color: #1976D2;
        }

        .figure-content {
            display: none;
            margin: 15px 0;
            padding: 20px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            text-align: center;
            animation: fadeIn 0.3s ease;
        }

        .figure-content.show {
            display: block;
        }

        .figure-content img {
            max-width: 100%;
            height: auto;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            background: #323232;
            color: white;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .toast.show {
            opacity: 1;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        /* Floating Navigation */
        .floating-nav {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
        }

        .floating-nav a {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: #2196F3;
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
            transition: all 0.3s ease;
        }

        .floating-nav a:hover {
            background: #1976D2;
            box-shadow: 0 6px 16px rgba(33, 150, 243, 0.4);
            transform: translateY(-2px);
        }

        .floating-nav svg {
            width: 18px;
            height: 18px;
        }
    </style>
</head>
<body>
    <!-- Floating Navigation -->
    <div class="floating-nav">
        <a href="https://www.mathtrauma.com" target="_blank" rel="noopener noreferrer">
            <svg fill="currentColor" viewBox="0 0 20 20">
                <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/>
            </svg>
            mathtrauma.com
        </a>
    </div>

    <div class="container">
        <!-- 왼쪽 사이드바 -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>기하 문제 관리</h1>
                <div class="stats" id="stats">
                    로딩 중...
                </div>
            </div>

            <div class="search-box">
                <input type="text" id="searchInput" placeholder="문제 검색...">
            </div>

            <div class="problem-list" id="problemList">
                <div class="loading">문제 목록 로딩 중...</div>
            </div>
        </div>

        <!-- 오른쪽 메인 영역 -->
        <div class="main">
            <div class="main-header">
                <h2 id="currentProblemTitle">문제를 선택하세요</h2>
                <div class="tabs">
                    <button class="tab active" data-tab="view">문제 보기</button>
                    <button class="tab" data-tab="metadata">메타데이터</button>
                </div>
            </div>

            <div class="content-area">
                <!-- 문제 보기 탭 -->
                <div class="tab-content active" id="tab-view">
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
                        </svg>
                        <p>왼쪽 목록에서 문제를 선택하세요</p>
                    </div>
                </div>

                <!-- 메타데이터 탭 -->
                <div class="tab-content" id="tab-metadata">
                    <div class="empty-state">
                        <p>문제를 선택하세요</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast notification -->
    <div class="toast" id="toast"></div>

    <script>
        let currentProblemId = null;
        let allProblems = [];
        let problemsData = {};
        let problemHierarchy = null;
        let expandedFolders = new Set();
        let currentFilteredProblems = null;

        // 초기화
        window.addEventListener('DOMContentLoaded', () => {
            loadProblems();
            setupTabs();
            setupSearch();
        });

        // 문제 데이터 로드 (번들 JSON 파일)
        async function loadProblems() {
            try {
                const response = await fetch('problems_bundle.json');
                const data = await response.json();

                allProblems = data.problems;

                // 빠른 조회를 위한 맵 생성
                problemsData = {};
                allProblems.forEach(p => {
                    problemsData[p.id] = p;
                });

                updateStats(data);
                renderProblemList(allProblems);
            } catch (error) {
                console.error('Failed to load problems:', error);
                showToast('문제 목록을 불러오는데 실패했습니다.');
            }
        }

        // 문제 분류 함수
        function classifyProblem(problem) {
            const source = problem.source || '';

            // KMO 중등부 1차: Extract year from "제38회(2024) KMO 중등부 1차 N번" or "38회(2024) KMO 중등부 1차 N번"
            const kmoMatch = source.match(/제?(\d+)회\((\d{4})\)\s*KMO\s*중등부\s*1차/);
            if (kmoMatch) {
                return { category: 'kmo_middle_1', year: kmoMatch[2], problem };
            }

            // Empty source
            if (!source.trim()) {
                return { category: 'no_source', year: null, problem };
            }

            // Everything else
            return { category: 'other', year: null, problem };
        }

        // 계층 구조 빌더
        function buildHierarchy(problems) {
            const hierarchy = {
                kmo_middle_1: { label: 'KMO 중등부 1차', folders: {}, count: 0 },
                no_source: { label: '출처 미분류', problems: [], count: 0 },
                other: { label: '기타 문제', problems: [], count: 0 }
            };

            problems.forEach(problem => {
                const { category, year } = classifyProblem(problem);

                if (category === 'kmo_middle_1') {
                    if (!hierarchy.kmo_middle_1.folders[year]) {
                        hierarchy.kmo_middle_1.folders[year] = {
                            label: year,
                            problems: [],
                            count: 0
                        };
                    }
                    hierarchy.kmo_middle_1.folders[year].problems.push(problem);
                    hierarchy.kmo_middle_1.folders[year].count++;
                    hierarchy.kmo_middle_1.count++;
                } else {
                    hierarchy[category].problems.push(problem);
                    hierarchy[category].count++;
                }
            });

            // Sort years descending (2024 → 2011)
            const sortedYears = Object.keys(hierarchy.kmo_middle_1.folders).sort((a, b) => b - a);
            const sortedFolders = {};
            sortedYears.forEach(year => {
                sortedFolders[year] = hierarchy.kmo_middle_1.folders[year];
            });
            hierarchy.kmo_middle_1.folders = sortedFolders;

            return hierarchy;
        }

        // 폴더 상태 관리
        function toggleFolder(folderId) {
            if (expandedFolders.has(folderId)) {
                expandedFolders.delete(folderId);
            } else {
                expandedFolders.add(folderId);
            }
            if (!currentFilteredProblems) {
                renderProblemList(allProblems);
            }
        }

        function isFolderExpanded(folderId) {
            return expandedFolders.has(folderId);
        }

        // 통계 업데이트
        function updateStats(data) {
            const total = data.total_problems;
            const withSolution = allProblems.filter(p => p.solution).length;
            const completionRate = total > 0 ? Math.round(withSolution / total * 100) : 0;

            document.getElementById('stats').textContent =
                `전체: ${total} | 풀이: ${withSolution} | 완료율: ${completionRate}%`;
        }

        // 문제 목록 렌더링
        function renderProblemList(problems) {
            const listContainer = document.getElementById('problemList');
            listContainer.innerHTML = '';

            if (!currentFilteredProblems) {
                // Normal mode: hierarchical view
                problemHierarchy = buildHierarchy(problems);
                renderHierarchy(listContainer, problemHierarchy);
            } else {
                // Search mode: grouped flat list
                renderSearchResults(listContainer, problems);
            }
        }

        function renderHierarchy(container, hierarchy) {
            // Render KMO category with year sub-folders
            if (hierarchy.kmo_middle_1.count > 0) {
                renderCategoryFolder(container, 'kmo_middle_1', hierarchy.kmo_middle_1, true);
            }

            // Render 출처 미분류
            if (hierarchy.no_source.count > 0) {
                renderCategoryFolder(container, 'no_source', hierarchy.no_source, false);
            }

            // Render 기타 문제
            if (hierarchy.other.count > 0) {
                renderCategoryFolder(container, 'other', hierarchy.other, false);
            }
        }

        function renderCategoryFolder(container, categoryId, category, hasSubFolders) {
            const isExpanded = isFolderExpanded(categoryId);

            const folderDiv = document.createElement('div');
            folderDiv.className = 'folder-item category-folder';
            folderDiv.innerHTML = `
                <div class="folder-header" data-folder-id="${categoryId}">
                    <span class="folder-icon ${isExpanded ? 'expanded' : ''}">${isExpanded ? '▼' : '▶'}</span>
                    <span class="folder-label">${category.label}</span>
                    <span class="folder-count">(${category.count})</span>
                </div>
            `;

            folderDiv.querySelector('.folder-header').onclick = (e) => {
                e.stopPropagation();
                toggleFolder(categoryId);
                renderProblemList(allProblems);
            };

            container.appendChild(folderDiv);

            if (isExpanded) {
                const contentDiv = document.createElement('div');
                contentDiv.className = 'folder-content';

                if (hasSubFolders) {
                    // Render year folders (최신 연도 먼저)
                    Object.keys(category.folders).sort((a, b) => b - a).forEach(year => {
                        renderYearFolder(contentDiv, categoryId, year, category.folders[year]);
                    });
                } else {
                    // Render problems directly
                    category.problems.forEach(problem => {
                        renderProblemItem(contentDiv, problem, 1);
                    });
                }

                container.appendChild(contentDiv);
            }
        }

        function renderYearFolder(container, parentId, year, yearData) {
            const folderId = `${parentId}_${year}`;
            const isExpanded = isFolderExpanded(folderId);

            const folderDiv = document.createElement('div');
            folderDiv.className = 'folder-item year-folder';
            folderDiv.innerHTML = `
                <div class="folder-header" data-folder-id="${folderId}">
                    <span class="folder-icon ${isExpanded ? 'expanded' : ''}">${isExpanded ? '▼' : '▶'}</span>
                    <span class="folder-label">${year}</span>
                    <span class="folder-count">(${yearData.count})</span>
                </div>
            `;

            folderDiv.querySelector('.folder-header').onclick = (e) => {
                e.stopPropagation();
                toggleFolder(folderId);
                renderProblemList(allProblems);
            };

            container.appendChild(folderDiv);

            if (isExpanded) {
                const contentDiv = document.createElement('div');
                contentDiv.className = 'folder-content';

                yearData.problems.forEach(problem => {
                    renderProblemItem(contentDiv, problem, 2);
                });

                container.appendChild(contentDiv);
            }
        }

        function renderProblemItem(container, problem, indentLevel) {
            const item = document.createElement('div');
            item.className = 'problem-item';
            item.style.paddingLeft = `${15 + (indentLevel * 20)}px`;

            if (currentProblemId === problem.id) {
                item.classList.add('active');
            }

            item.onclick = () => selectProblem(problem.id);

            let badges = '';
            if (problem.has_tikz) badges += '<span class="badge badge-tikz">TikZ</span>';
            if (problem.solution) badges += '<span class="badge badge-solution">풀이</span>';
            if (problem.source) badges += '<span class="badge badge-source">출처</span>';

            item.innerHTML = `
                <div class="problem-id">문제 ${problem.id}</div>
                <div class="problem-preview">${problem.source || problem.source_file || '원본 파일 없음'}</div>
                <div class="problem-badges">${badges}</div>
            `;

            container.appendChild(item);
        }

        function renderSearchResults(container, problems) {
            const classified = buildHierarchy(problems);

            // KMO problems
            if (classified.kmo_middle_1.count > 0) {
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'search-category-header';
                categoryHeader.textContent = `${classified.kmo_middle_1.label} (${classified.kmo_middle_1.count})`;
                container.appendChild(categoryHeader);

                Object.keys(classified.kmo_middle_1.folders).sort((a, b) => b - a).forEach(year => {
                    const yearFolder = classified.kmo_middle_1.folders[year];
                    const yearHeader = document.createElement('div');
                    yearHeader.className = 'search-year-header';
                    yearHeader.textContent = `${year} (${yearFolder.count})`;
                    container.appendChild(yearHeader);

                    yearFolder.problems.forEach(problem => {
                        renderProblemItem(container, problem, 2);
                    });
                });
            }

            // No source problems
            if (classified.no_source.count > 0) {
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'search-category-header';
                categoryHeader.textContent = `${classified.no_source.label} (${classified.no_source.count})`;
                container.appendChild(categoryHeader);

                classified.no_source.problems.forEach(problem => {
                    renderProblemItem(container, problem, 1);
                });
            }

            // Other problems
            if (classified.other.count > 0) {
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'search-category-header';
                categoryHeader.textContent = `${classified.other.label} (${classified.other.count})`;
                container.appendChild(categoryHeader);

                classified.other.problems.forEach(problem => {
                    renderProblemItem(container, problem, 1);
                });
            }
        }

        // 문제 선택
        function selectProblem(problemId) {
            currentProblemId = problemId;

            // 목록에서 선택 표시
            document.querySelectorAll('.problem-item').forEach(item => {
                item.classList.remove('active');
                const idText = item.querySelector('.problem-id')?.textContent;
                if (idText && idText.includes(problemId)) {
                    item.classList.add('active');
                }
            });

            loadProblem(problemId);
        }

        // 문제 상세 로드
        function loadProblem(problemId) {
            const problem = problemsData[problemId];
            if (!problem) {
                showToast('문제를 찾을 수 없습니다.');
                return;
            }

            // 제목 업데이트
            document.getElementById('currentProblemTitle').textContent = `문제 ${problemId}`;

            // 문제 내용 표시
            const viewTab = document.getElementById('tab-view');
            if (problem.content) {
                let contentHtml = convertLatexToHtml(problem.content);

                // solution에서 SVG 마커 추출하여 문제 아래에 추가
                if (problem.solution) {
                    const svgButtons = extractSvgButtons(problem.solution);
                    if (svgButtons) {
                        contentHtml += svgButtons;
                    }
                }

                viewTab.innerHTML = `<div class="problem-content">${contentHtml}</div>`;
            } else {
                viewTab.innerHTML = '<div class="empty-state"><p>문제 내용이 없습니다.</p></div>';
            }

            // 메타데이터 표시
            const metadataTab = document.getElementById('tab-metadata');
            metadataTab.innerHTML = `
                <div class="metadata-view">
                    <div class="metadata-item">
                        <strong>문제 ID</strong>
                        ${problem.id}
                    </div>
                    ${problem.source ? `
                    <div class="metadata-item">
                        <strong>출처</strong>
                        ${problem.source}
                    </div>` : ''}
                    ${problem.answer ? `
                    <div class="metadata-item">
                        <strong>답안</strong>
                        ${problem.answer}
                    </div>` : ''}
                    ${problem.category ? `
                    <div class="metadata-item">
                        <strong>카테고리</strong>
                        ${problem.category}
                    </div>` : ''}
                    ${problem.difficulty ? `
                    <div class="metadata-item">
                        <strong>난이도</strong>
                        ${problem.difficulty}/5
                    </div>` : ''}
                    ${problem.tags && problem.tags.length > 0 ? `
                    <div class="metadata-item">
                        <strong>태그</strong>
                        ${problem.tags.join(', ')}
                    </div>` : ''}
                    ${problem.note ? `
                    <div class="metadata-item">
                        <strong>메모</strong>
                        ${problem.note}
                    </div>` : ''}
                    <div class="metadata-item">
                        <strong>원본 파일</strong>
                        ${problem.source_file}
                    </div>
                    <div class="metadata-item">
                        <strong>TikZ 사용</strong>
                        ${problem.has_tikz ? '예' : '아니오'}
                    </div>
                </div>
            `;

            // MathJax 렌더링
            if (window.MathJax) {
                MathJax.typesetPromise([viewTab]);
            }

            // 폴드아웃 버튼 이벤트 설정
            setupFigureToggles();
        }

        // solution에서 SVG 마커 추출하여 폴드아웃 버튼 HTML 생성
        function extractSvgButtons(solution) {
            if (!solution) return '';

            const svgMarkers = [];
            const regex = /%\s*\[SVG:\s*([^\]]+)\]/g;
            let match;

            while ((match = regex.exec(solution)) !== null) {
                svgMarkers.push(match[1].trim());
            }

            if (svgMarkers.length === 0) return '';

            let buttonsHtml = '';
            svgMarkers.forEach((filename, index) => {
                const svgPath = `data/svg/${filename}`;
                const label = svgMarkers.length > 1 ? `그림 ${index + 1} 보기` : '그림 보기';
                buttonsHtml += `
                    <div class="figure-toggle" data-svg="${svgPath}">
                        <div class="figure-toggle-icon">
                            <svg viewBox="0 0 24 24">
                                <path d="M8 5v14l11-7z"/>
                            </svg>
                        </div>
                        <span class="figure-toggle-text">${label}</span>
                    </div>
                    <div class="figure-content">
                        <img src="${svgPath}" alt="그림" loading="lazy">
                    </div>
                `;
            });

            return buttonsHtml;
        }

        // LaTeX를 HTML로 변환 (수식 보호)
        function convertLatexToHtml(latex) {
            if (!latex) return '';

            let html = latex;

            // 1. 수식을 임시로 보호 (치환)
            const mathPlaceholders = [];
            let mathIndex = 0;

            // Display math $$...$$ 보호
            html = html.replace(/\$\$([\s\S]*?)\$\$/g, (match) => {
                const placeholder = `___DISPLAYMATH_${mathIndex}___`;
                mathPlaceholders.push({ placeholder, content: match });
                mathIndex++;
                return placeholder;
            });

            // Inline math $...$ 보호
            html = html.replace(/\$([^\$]+?)\$/g, (match) => {
                const placeholder = `___INLINEMATH_${mathIndex}___`;
                mathPlaceholders.push({ placeholder, content: match });
                mathIndex++;
                return placeholder;
            });

            // 2. LaTeX 명령어 처리
            // \numbering 제거
            html = html.replace(/\\numbering\s*/g, '<strong>문제.</strong> ');

            // 환경 변환
            html = html.replace(/\\begin\{problem\}/g, '<div class="problem-box">');
            html = html.replace(/\\end\{problem\}/g, '</div>');
            html = html.replace(/\\begin\{center\}/g, '<div style="text-align:center;">');
            html = html.replace(/\\end\{center\}/g, '</div>');
            html = html.replace(/\\begin\{figure\}(\[.*?\])?/g, '<div class="figure">');
            html = html.replace(/\\end\{figure\}/g, '</div>');

            // 줄바꿈 (문장 끝의 \\만 변환)
            html = html.replace(/\\\\(?=\s*$)/gm, '<br>');
            html = html.replace(/\\\\(?=\s*\n)/g, '<br>');
            html = html.replace(/\\newline/g, '<br>');

            // \vfill, \vspace 등 제거
            html = html.replace(/\\vfill/g, '');
            html = html.replace(/\\vspace\{[^}]*\}/g, '');
            html = html.replace(/\\hspace\{[^}]*\}/g, '');

            // 단락 구분
            html = html.replace(/\n\n+/g, '</p><p>');

            // 3. 수식 복원
            mathPlaceholders.forEach(({ placeholder, content }) => {
                html = html.replace(placeholder, content);
            });

            // 4. 마침표 다음 줄바꿈을 <br>로 변환
            // 마침표 뒤에 개행 문자가 있고, 그 다음에 한글/영문/숫자가 오면 <br>로 변환
            html = html.replace(/\.\s*\n\s*([가-힣A-Za-z0-9$])/g, '.<br>$1');

            // 5. 수식 뒤에 공백 추가 (수식 바로 뒤 한글/영문이 오면)
            // Inline math $...$ 뒤에 한글/영문이 바로 오면 공백 추가
            html = html.replace(/(\$[^\$]+?\$)([가-힣a-zA-Z])/g, '$1 $2');
            // Display math $$...$$ 뒤에 한글/영문이 바로 오면 공백 추가
            html = html.replace(/(\$\$[^\$]+?\$\$)([가-힣a-zA-Z])/g, '$1 $2');

            // 6. 단락으로 감싸기
            if (!html.startsWith('<div') && !html.startsWith('<p')) {
                html = '<p>' + html + '</p>';
            }

            // 빈 단락 제거
            html = html.replace(/<p>\s*<\/p>/g, '');

            // 7. SVG 마커를 폴드아웃 버튼으로 변환
            // % [SVG: filename.svg] 형식 처리
            html = html.replace(/%\s*\[SVG:\s*([^\]]+)\]/g, (match, filename) => {
                const svgPath = `data/svg/${filename.trim()}`;
                return `
                    <div class="figure-toggle" data-svg="${svgPath}">
                        <div class="figure-toggle-icon">
                            <svg viewBox="0 0 24 24">
                                <path d="M8 5v14l11-7z"/>
                            </svg>
                        </div>
                        <span class="figure-toggle-text">그림 보기</span>
                    </div>
                    <div class="figure-content">
                        <img src="${svgPath}" alt="그림" loading="lazy">
                    </div>
                `;
            });

            return html;
        }

        // 폴드아웃 버튼 이벤트 설정
        function setupFigureToggles() {
            document.querySelectorAll('.figure-toggle').forEach(toggle => {
                toggle.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const isExpanded = content.classList.contains('show');

                    if (isExpanded) {
                        content.classList.remove('show');
                        this.classList.remove('expanded');
                        this.querySelector('.figure-toggle-text').textContent = '그림 보기';
                    } else {
                        content.classList.add('show');
                        this.classList.add('expanded');
                        this.querySelector('.figure-toggle-text').textContent = '그림 숨기기';
                    }
                });
            });
        }

        // 탭 설정
        function setupTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.dataset.tab;

                    // 탭 활성화
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    // 콘텐츠 표시
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.getElementById(`tab-${tabName}`).classList.add('active');
                });
            });
        }

        // 검색 설정
        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();

                if (query.trim() === '') {
                    // Clear search mode
                    currentFilteredProblems = null;
                    renderProblemList(allProblems);
                    return;
                }

                // Filter problems
                const filtered = allProblems.filter(p => {
                    return p.id.includes(query) ||
                           (p.source && p.source.toLowerCase().includes(query)) ||
                           (p.source_file && p.source_file.toLowerCase().includes(query)) ||
                           (p.tags && p.tags.some(tag => tag.toLowerCase().includes(query)));
                });

                // Enter search mode
                currentFilteredProblems = filtered;
                renderProblemList(filtered);
            });
        }

        // 토스트 알림
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
    </script>
</body>
</html>
